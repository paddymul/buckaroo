import{j as t}from"./jsx-runtime-DiklIkkE.js";import{r as a}from"./index-DRjF_FHU.js";import{a as g}from"./gridUtils-C-o1KBgq.js";import{S as _}from"./StoryUtils-B3A1VrTU.js";import{d as p,c as w,a as h}from"./DFViewerDataHelper-l27HaZum.js";import"./lodash-CGIzQN7T.js";import"./HistogramCell-WXbqT_Ov.js";import"./index-Bx0Ph3cE.js";import"./ChartCell-CdGzSEf4.js";import"./tiny-invariant-CopsF_GD.js";import"./main.esm-CraDeAap.js";import"./client-DQginrwT.js";const x={col_name:"index",header_name:"index",displayer_args:{displayer:"obj"}},i=e=>({col_name:e,header_name:e,displayer_args:{displayer:"obj"}}),b={column_config:[i("a"),i("b")],left_col_configs:[x],pinned_rows:[{primary_key_val:"null_count",displayer_args:{displayer:"obj"}},{primary_key_val:"empty_count",displayer_args:{displayer:"obj"}}]},j=p({a:h(5),b:["x","y","z","w","v"]}),n=e=>e==="loading"?[{index:"null_count",a:"loading",b:"loading"},{index:"empty_count",a:"loading",b:"loading"}]:e==="first"?[{index:"null_count",a:0,b:"loading"},{index:"empty_count",a:2,b:"loading"}]:[{index:"null_count",a:0,b:1},{index:"empty_count",a:2,b:3}],v=()=>{const[e,o]=a.useState(n("loading")),[s,m]=a.useState(!1),u=a.useMemo(()=>{const y=s?j:p({a:[],b:[]});return w(y,0)},[s]),f=()=>{setTimeout(()=>m(!0),3e3),setTimeout(()=>o(n("first")),6e3),setTimeout(()=>o(n("second")),1e4)};return t.jsx(_,{children:t.jsxs("div",{style:{width:720},children:[t.jsx("p",{style:{marginBottom:8},children:'Scenario: Instantiate DFViewerInfinite with pinned rows configured. We first load initial pinned rows with the text "loading". After 3 seconds, the infinite row datasource returns 5 rows for the table body. After another 3 seconds, update only column "a" across the pinned rows (column-wise update). After a further 4 seconds, update column "b" across pinned rows. Expected: pinned rows remain visible and reflect column-wise updates progressively. Actual: depending on timing, the datasource render can clear pinned rows and reflect updates. Actual: depending on timing, the datasource render can clear pinned rows after they were applied, unless we re-apply them after the grid finishes binding (for example, in onFirstDataRendered) and on subsequent updates.'}),t.jsx("div",{style:{marginBottom:8},children:t.jsx("button",{onClick:f,children:"Start (apply stats, then recreate datasource)"})}),t.jsx("div",{style:{height:420},children:t.jsx(g,{data_wrapper:u,df_viewer_config:b,summary_stats_data:e,activeCol:["a","a"],setActiveCol:()=>{},outside_df_params:{}})})]})})},V={title:"Buckaroo/DFViewer/PinnedRowsRace",component:v,parameters:{layout:"centered"},tags:["autodocs"]},r={args:{}};var d,c,l;r.parameters={...r.parameters,docs:{...(d=r.parameters)==null?void 0:d.docs,source:{originalSource:`{
  args: {}
}`,...(l=(c=r.parameters)==null?void 0:c.docs)==null?void 0:l.source}}};const W=["Primary"];export{r as Primary,W as __namedExportsOrder,V as default};
